# 数据结构与算法(Python)
## 第一章 绪论
### 1.1数据结构的研究内容
通常一个问题会抽象出**数学模型**，然后找出其中的**关系**。最开始，是处理数值计算的。现在也经常进行处理非数值计算，比如：**信息处理**。

**应用的领域**：教务处理系统(增删改查)，人机对弈(操作的对象是一种树的关系)，文件系统的系统结构图(一对多的关系，树状图)，地图导航求最短路径(图数据结构，图上的地点是一个一个点，分析点到点的最短距离)

> 数据结构就是一门研究**非数值计算**的程序设计中计算机的操作对象以及它们之间**关系**和**操作**的学科

### 1.2 基本概念和术语
- 数据 : 定义：能够输入计算机并且能被计算机处理的各种符号的集合。
	- 信息的载体
	- 是对客观事物符号化的表示
	- 能够被计算机识别，存储并且加工
	- 包括了**数值数据**和**非数值数据**。
- 数据元素：也简称元素，或者被称为记录、结点或者顶点。它是数据的基本单位，在计算机程序中通常作为一个整体考虑和处理。 
	- 比如学生管理系统，数据元素就是一个学生。
	- 导航问题中就是每个地点。
	- 人机对弈就是状态
- 数据项 构成数据元素的不可分割的**最小单位**
	- 比如，在学生管理系统当中，数据项包括了学生的姓名，学号，性别，年龄等。
	- 数据、数据元素和数据项三者的关系：
		- 数据 > 数据元素 > 数据项
		- 比如： 学生表 > 学生 > 学号、年龄、性别...
- 数据对象： 是**性质相同的数据元素的集合**，是数据的一个子集
	- 比如**整数**的数据对象是集合N={0，1，2，3，-1，-2，-3...}
> 数据元素——是组成数据的基本单元(是集合的个体，或者说是数据中的一个)
> 
> 数据对象——性质相同的数据元素的集合(集合的子集)

- 数据结构包括三个方面的内容：
	- 1. 数据元素之间的逻辑关系，也成为**逻辑结构**
	- 2. 数据元素及其关系在计算机内存中的表示(也称为**映射**)，称为数据结构的**物理结构**或数据的**存储结构**
	- 3. 数据的**运算和实现**，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。

逻辑结构的种类：

- 划分方法一
	- (1) 线性结构
		- 有且仅有一个开始和终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继
		- 例如： 线性表、栈、队列、串
	- (2) 非线性机构
		- 不是一种一对一的关系，是一对多或者多对多的格局。
		- 例如： 树、图
- 划分方法二： 四种基本逻辑结构
	- （1） 集合结构： 


存储结构：

- 顺序存储结构： 用一组**连续**存储单元**依次**存储数据元素，数据元素之间的逻辑关系由元素的**存储位置**来表示
	- C语言中用数组来实现顺序存储结构，比如存储一个字符串("peach", "apple","banana")，那么存储的时候，采用顺序存储方式，它们的存储单元也应该是一个挨着一个的存储的。
- 链式存储结构：用**任意**存储单元来存储元素，数据元素之间的逻辑关系用**指针**来表示
	- C语言中，用指针来实现链式存储结构
	- 每个结构元素存储元素本身的同时，要存储元素下一个结构元素的地址(指针)
- 索引存储结构(Index)或者目录
	- 在存储结点信息的同时，建立索引
- 散列存储结构
	- 根据结点的关键字直接计算出该结点的存储地址

**数据类型和抽象数据类型**：

- 有些常用的数据类型，比如栈、队列、树、图等，无法直接用结构类型来表示
- 高级语言中的数据类型明显或隐式地规定了在程序执行期间变量和表达的所有可能的取值范围，以及这些数值范围上所允许进行的操作
	- 类如，C语言中定义的变量i为int类型，就表示i是[-min, max]范围的整数，在这个整数集上可以进行+ - * \ %等操作。
	- 数据类型的作用 
		- 约束变量或者常量的取值范围
		- 约束变量或者常量的操作
	

**数据类型(Data Type)**

- 定义： **数据类型**是一组性质相同的**值的集合**以及定义于这个值集合上的**一组操作**的总和

	**数据类型 = 值的集合 + 值集合上的一组操作**

**抽象数据类型(Abstract Data Type)**

- 指的是一个数学模型以及定义在此数学模型上的一组操作
	- 由用户定义，从问题抽象出**数据类型**(逻辑结构)
	- 还包括定义在数据模型上的一组抽象运算(相关操作)
	- 不考虑如何存

一个抽象数据类型的定义格式如下：

```
ADT 抽象数据类型名{
	数据对象：<数据对象的定义>
	数据关系：<数据关系的定义>
	数据操作：<数据操作的定义>
} ADT抽象数据类型名
```

其中

- 数据对象、结构相关的定义用伪代码来实现
- 基本操作的定义格式
	- 基本操作名称(参数表)
	- 初始条件(初始条件描述)
	- 操作结果(操作结果描述) 

**基本操作定义格式说明**：

- 参数表：赋值参数 只为操作提供输入值。引用参数以&打头，除可提供输入值外，还将返回操作结果。

- 初始条件： 描述操作执行之前数据结构和参数满足的条件，如果不满足，则操作失败，并返回相应的出错信息。如条件为空，则省略。

- 操作结果： 说明操作正常完成后，操作数据的变化

**例子： Circle的定义**
```
ADT Circle{
	数据对象： D = {r,x,y|r,x,y均为实数}
	数据关系： R = {<r,x,y>|r是半径 <x,y>是圆心坐标}
	基本操作： 
	Circle(&C,r,x,y) 操作结果是构造一个圆
	double Area(C)
		初始条件： 圆已经存在
		操作结果： 计算面积
	double Circleference()
		初始条件: 圆存在
		操作结果： 计算周长

}ADT Circle
```
### 1.3抽象数据类型的实现
这里可使用各种高级语言去实现，比如python、c++、c、java等等

**用C语言实现抽象数据类型**

使用C语言真正实现抽象数据类型的定义
```
typedef struct{
	float realpart; //实数部分
	float imagpart;//虚部部分
	void sign(Complex *A,float real, float imag);
	void add(Complex *C, Complex A, Complex B);
} Complex
Void assign(Complex *A, float real, float imag){
	A->realpart = real;
	A->imagpart = imag;
}
void add(Complex *c, Complex *A, Complex *B){
	c->realpart = A.realpart + B.realpart;
	c->imagpart = A.imagpart + B.imagepart;
}
```

### 1.4 算法和算法分析
**算法定义**
- 对特定问题**求解方法和步骤**的一种描述，它是**指令的有效序列**。其中每一条指令表示一个或者多个操作。

> 简而言之，算法就是解决问题的方法和步骤

- 算法的描述
	- 自然语言： 英语、中文
	- 流程图： 传统流程图，NS流程图
	- **伪代码**：类C语言
	- 程序代码： C语言

**算法与程序**：
- 一个问题可以有多种算法
- 程序是算法的具体的实现，程序是数据结构和算法的集合

**算法的五个重要特性**

- 有穷性
- 确定性
- 可行性
- 输入（零个或者多个输入）
- 输出（一个或者多个输出）

**算法设计的要求**

- 正确性
- 可读性
- 健壮性(Robustness,出现**异常**的机制)
- 高效性（尽量少，存储空间尽量少）

**算法的效率**

- 时间效率
- 空间效率

> 时间和空间有时候是矛盾的，需要综合考虑

**分析的方法**


- 事后统计
	- 首先转化成程序
	- 环境的好坏也会影响
- 事前分析
	- 算法运行时间 = 一个简单操作所需要的时间x简单操作次数
	- 比较算法的数量级，为O(f(n))为算法的渐进时间复杂度，称为**时间复杂度**
	- 没必要把所有语句的执行次数找出来，只用考虑算法中**基本操作**执行的次数，它是问题规模n的某个函数，可以用T(n)表示。
		- **基本操作次数**
		- **问题规模**

**分析时间复杂度的基本方法**

- 1. 找出语句中频率最高的那条语句作为**基本语句**
- 2. 计算基本语句的频率得到问题规模n的某个函数f(n)
- 3. 取其数量级符号'O'表示

**一个例子**
```
i = 1
while(i < n){
	i = i * 2;
}
```

这个问题的时间复杂度为O(lgN)

**时间复杂度**还与其输入的参数不同，也会造成不同，比如：在顺序查找中最好的情况是第一个就匹配上，最坏的情况是遍历全部，平均时间复杂度为O(n)

- 最坏时间复杂度(一般考虑最坏的情况，因为是最坏了，所以时间有保障)
- 平均时间复杂度
- 最好时间复杂度
- 对于复杂的算法，可以将其分别求解，然后再进行加法或者乘法运算，计算算法的时间复杂度：
	- (a) 加法法则： $T(n) = T_1(n) + T_2(n) = O(f(n))+O(g(n)) =O(max(f(n),g(n))%
	- (b)乘法法则：$O(f(n)*g(n))$

**算法时间效率的比较**：常数阶< 对数阶 < 线性阶 < 线性对数阶 < 次方阶 < 指数阶

> 考虑时，尽量选择复杂度低的

**算法的空间复杂度**

- 空间复杂度: 算法所存储的空间的衡量
- 算法要占据的空间
	- 算法本身所占据的空间，输入/输出、指令、常数、变量等
	- 算法要使用的**辅助空间**

【例子】将一维数组a中的n各数逆序放到原始数据中：

```
alogrithm one:
for(i = 1;i < n / 2;i++){
	t = a[i];
	a[i] = a[n-i-1];
	a[n-i-1] = t;
}
alogrithm two:
for(i=1;i<n;i++){
	b[i] = a[n-i-1];
}
for(i=1;i<n;i++){
	a[i] = b[i];
}
```
> 算法一的空间复杂为O(1)，算法二的空间复杂度为O(n)



### 总结
处理的数据不再是纯数字，而是非数值结构，它们有一定的结构，如果处理？

- 逻辑结构： 研究对象的特性及其相互之间的关系
- 存储结构： 有效组织计算机存储
- 算法：有效实现对象之间的"运算"关系 

用计算机处理问题要是能够计算能够识别的数据。

数据->(个体)数据元素(性质相同的集合)->据对象 ->(加上数据元素之间的关系)->数据结构(逻辑模型)


**设计好的算法的过程**

抽象数据类型 = 数据的逻辑结构+抽象运算(运算功能的描述)

## 第二章 线性表

数据结构 = 数据的逻辑结构(线性结构(线性表、栈、队列、字符串、数组和广义表)和非线性结构(树形结构和图形结构))+数据存储结构(顺序存储和链式存储)+数据的运算(检索、排序、插入、删除或修改)

### 2.1 线性表的定义和特点
**线性表**是就有相同特性的数据元素的一个有限序列。

术语：

- 起始节点(只有一个)
- 直接前趋(中间结点只有一个)
- 直接后继(中间结点只有一个)
- 下标
- 终端节点(只有一个)

> 线性表例子： 26个英文字母、某个单位拥有计算机的数量、学生情况等级表、12个星座

### 2.2 案例的引入

【案例一】 一元多项式的加减乘除

**顺序表存在的问题**

- 存储空间的分配不灵活
- 运算的空间复杂度高

> 改进方法：采用链式存储结构

【图书信息管理系统】功能：查找、删除、排序、计数、修改
### 2.3 线性的类型定义

抽象数据类型： 具体问题抽象出来的问题

基本的功能

- 创造线性表
- 求线性表长度
- 线性表是否为空
- 线性表增删插修
- 获得元素的前驱和后继
- 遍历(对每个元素都要操作)

> 存储结构很关键!!!!!!

### 2.4 线性表的顺序表示

**顺序存储结构**：逻辑上相邻的数据存储在物理上相邻的存储结构

线性表顺序存储结构占用一片连续的存储空间，知道某个元素的存储位置就可以知道其他元素的存储位置。**这也使得访问某个元素的数据的时间复杂度为O(1)**

可以用一维数组来表示线性表：

- 地址连续
- 依次存放
- 随机存取
- 类型相同

> 线性表长度可变， 但是C++/C语言中数组的长度不可变

**通过添加一个存储线性表长度的变量来实现动态数组！**

```
typedef structure{
	ElemType *data;//定义线性表首地址，自定义类型。这种表示为动态存放。
	int length; //存储线性表长度
}SqList //顺序线性表

C语言中的内存动态分配
Sqlist;
Ldata = (ElemType *)malloc(sizeof(ElemType)*MaxSize)
ps: malloc(m)：开辟m字节长度的地址空间，并返回这段空间的首地址
```
C++语法
```
new 类型名T(初始列表)
	int* p1 = new(int)
	或 int *p1 = new int(10)
	功能：申请用于存放

delete 指针P
```

**补充C++中参数的传递**

- 函数调用时传送给形参的实参必须与形参三个一致
- 参数传递的两个方式
	- 值传递(值传递的形参不会影响实参)
	- 引用传递(传递的是别名，通过对别名的操作会影响实参)
	- 指针传递(形参可以影响实参，也可以不影响实参，具体情况根据操作的是地址还是地址存储的东西决定。**关键在于函数的生命周期结束会释放空间**)

> 顺序表中除数组之外，还需要保存一个数字(顺序表的长度)

```c++
//函数结果的状态代码
#define TRUE 1 
#define FALSE 0
#define OK 1
#define ERROR -2
#define INFEASIBLE -1
#define OVERFLOW -2
//Status 是函数的类型，其值就是函数结果状态代码
typedef int Status;
typedef char ElmTtype;

Status Init_Sq(Sqlist &L){
	L.elem = new ElemType[MAXSIZE];
	if(!L.elem) exit(OVERLOW);
	L.length = 0;
	return OK;
}
```

**查找操作**

- 顺序查找的平均时间复杂度为`O(n)`也叫期望值。

**插入算法**

- 需要找到另外一块存储空间，将插入位置前的元素依次往前移动。平均复杂度为`O(n)`。

**删除算法**

- 与插入算法类似，平均复杂度为`O(n)`

**顺序表的特点**

- 利用数据元素的存储位置表示线性表中相邻数据元素之间的前后关系，即线性表的逻辑结构与物理结构是一致的
- 在访问线性表时，可以快速定位到任何一个数据元素的存储位置，因此可以粗略地认为访问每个元素所用时间相等。
- 这种存取元素的方法称为**随机存取法**

**优点**

- 存储密度大
- 可以随机存取任意元素

**缺点**

- 插入删除要移动大量元素
- 浪费存储空间
- 属于静态存储形式，数据元素的个数不能自由扩充

### 2.5 线性表的链式表示 
链式表： 用**物理任意**位置的存储空间来存放数据。在存储本身的同时，要存储下一个位置。(数据域+指针域)

**相关术语**

- 结点(数据+指针)
- 链表
- 单链表/双链表/循环链表
- 头指针、头结点(附加结点)和首元结点

讨论1： 如果表示空表？

讨论2： 头结点的好处？

- 方便首元结点的处理，首元不需要特殊处理
- 便于空表和非空表的判断

讨论3： 头结点内装什么？

- 可以为空，可以表示表长

链式表的特点

- 存储的位置是随机的，称为**顺序存取**(区别于存储，链式线性表的存储是随机的，**但是存取是随机的**。顺序线性表的存取是随机的，即不从第一个开始存或者取)
- 访问的时候要从头指针开始，简称"顺藤摸瓜"(不同于顺序线性表的访问)

**单链表存储结构**

- 实现方式： 结构体(存储本身数据+指针)

```
typedef struct Lnode{
	ElemType data;
	struct Lnode* next;
}node *LinkList
```

**单链表基本操作的实现**

- 单链表的初始化(带头结点)
```
Status LinkList_L(LinkList &L){
	L = new LNode;//空结点
	L->next = NULL;
	return OK;
}
```
- 判断链表是否为空(头指针的指针域是否为空)
```c++
Status LinkList_L(LinkList L){
	if(L->next){
		return 0;
	}
	else{
		return 1;
	}
}
```
**单链表的销毁**

从头指针开始，依次释放所有结点。
先将头结点的指针指向下一个结点，然后删除上一个结点。
```c++
Status DestoryList_L(LinkList &L){
	LNode *p;
	while(L){
		p = L;
		L = L.next;
	 	delete p;
	}
	return OK;
}
```
**清空单链表**

【思路】： 依次将所有的结点释放，把头结点指针设置为空
```
Status ClearList_L(LinkList &L){
	Lnode *p,*q;	
	p = L->next;
	while(p != NULL){
		q = p->next;
		delete p;
		p = q;
	}
	L->next = NULL;
	return OK;
}
```

**求链表的表长**

【思路】 从首元结点开始，依次计数所有结点，
```
int CountList(LinkList L){
	int count = 0;	
	Lnode *p;
	p = L.next;
	while(p != NULL){
		count ++;
		p = p.next;
	}
	return count;
}
```

**单链表的取第i个值**

【思路】需要从第一个元素开始，顺藤摸瓜
```
Status Data(LinkList L, int im ElemType &e){
	p = L->next; //头
	j = 1;	
	while(p&&j<i) {
		p = p->next;//指向下一个
		++j;
	}
	if(!p||j>1) return ERROR;
	e = p->data;
	return OK;
}
```

**按值查找(得到地址)**

【思路】指针指向第一个元素，然后遍历进行匹配是否匹配。
```
Lnode Find(LinkList L,ElemType e){
	Lnode node;
	node = L->next;
	while(node && node->data!=e){
		node = node->next;
	}
	return p;
}
int LocateElem(LinkList L, ElemType e)
{
	p = L->next;
	j = 1;
	while(p!=NULL&&p->data!=e)
	{	
		p = p->next;
		j++;
	}
	if(p) return j;
	if(p) reutrn 0;
}
```

**插入操作**

【思路】修改i-1个结点的next指针，并且修改要插入的结点的next指针。
```
Status Inert(LinkList $L, int i,ElemType(包含数据和指针的那个) &e){
	//首先拿到第i-1个结点的地址
	Lnode p = L.next; //该结点是头(0)
	for(int count = 1;count<i;count++)
	{
		p = p->next;//现在的p就是第i-1个的地址
	}
	if(p) return ERROR;
	e.next = p.next;
	p.next = &e;
	return OK;
}
```

**删除第i个结点**

【思路】 首先找到第i-1个结点，修改成第i个结点的next；
```
Status Delete(LinkList &L, int i, ElemType &e){
	//找到第i-1个结点
	int j = 0;
	Lnode p = L.next;
	while(p && j < i - 1){
		p = p->next;
	}
	if(p==NULL) return ERROR;
	q = p->next;//第i个结点地址
	p->next = q->next;
	e = q->data;
	delete q;
	return OK;
}
```

**时间效率分析**

- 查找: 平均O(n)
- 插入: 平均O(n)(操作的时间复杂度为O(1))
- 删除: 平均O(n)(操作的时间复杂度为O(1))

**头插法**
- 从一个空表开始，重复读入数据
- 生成新结点，将读入数据放到新节点的数据中
- 从最后一个结点开始，依次将各个插入到链表的前端
```
void CreateList_H(LinkList &L, int n)
{
	L = new LinkList;
	L.next = NULL;
	int i = n;
	for(i;i>0;--i)
	{	
		ElemType data;//用于存放第i个结点的数据域
		Lnode p = new Lnode;//开辟第i个结点的空间
		p->next = L->next;//新节点连接上一个结点
		L->next = p;//头结点指向新插入的结点
		cin>>data;
		p.data = data;//将输入的数据域存储到相应的位置
	}
}
```

**尾插法建立单链表**

【思路】从一个空表L开始，将新节点逐个插入链表的尾部，尾指针指向新插入的节点。
```
void CreateList_R(LinkList &L, int n)
{
	//首先开辟头部的空间
	Lnode L = new Lnode;
	r = L;//尾指针指向头部节点
	L.next = NULL;
	for(int i = 0;i<n;i++)
	{
		Lnode p = new Lnode;//开辟新的空间
		cin>>p->data;
		p.next = NULL;
		r->next = p;
		r = p;
	}
}
时间复杂度为O(n)
```
**循环列表**
- 尾节点指针域指向第一个
- 从任意节点开始出发，都可以找到其他节点

> 循环列表中没有空指针，遍历循环条件是是否为头指针`p!=NULL ----> p!=header`

- 操作头尾节点的方法:
	- a1存储的位置是: `R->nexat->next`
	- an存储的位置是: `R`
	- 时间复杂度为O(1)

**合并两个循环链表的方法**
- 前提： 有一个临时变量保存第一个的头地址
- 首先，将前面那个链表的尾指针改为指向第二链表的头指针
- 然后，将第二个链表的尾指针改为指向第一个链表的头指针
```
LinkList Connect(LinkList Ta, LinkList Tb){
	if(Ta||Tb) return ERROR;
	p = Ta.next;
	Ta->next = Tb.next.next;
	Tb->next = p;
	delete Tb.next;
	return Tb;
}
时间复杂度为O(1)
```
**双向链表**
- 由于单向链表不能查找上一个节点
- 双向链表的结点保存了上一个结点和下一个结点的地址，此外还有本身的数据类型


**双向循环链表**
- 和单向链表类似，双向链表也可以有循环表
	- 和头节点前驱指针指向链表得尾节点
	- 具有对称性
	- 求链表的长度只需要一条链找到。
	- 与单链表不同在于删除和插入

**双向链表的插入**

- 找到插入节点的地址，修改前驱节点的后继和后继节点的前驱。
- 
```c++ 双向链表的插入算法
void ListInsert_Dul(DuLinkList &L, int i, ElemType e){
	//首先插入就要开辟新的内存空间
	DoNode s = new DouNode;
	s.data = e;
	//找到第i个节点的地址
	DouNode p = L->next;//第一个节点的地址
	for(int count = 1;count<i;count++){
		p = p->next;
	}
	//p是第i个节点的地址
	p->prior = s;
	p->prior->next = s;
	s.next = p;
	s->prior = p->prior;
```

**双向链表的删除操作**
```
void ListDelet_Dou(DouLinkList &L,int i, ElemType &e)
{
	//删除第i个节点，首先定位到第i个节点的地址
	if(!p=GetElemP_Dol(L,i)) return ERROR;
	e = p->data;
	p->prior->next = p->next;
	p->next->prior = p->prior;
	delete p;
	return OK;
}
```

**单链表、循环链表和双向链表的时间效率比较**

| 链表形式 | 查找表头节点(首元素) | 查找表尾节点 | 查找节点*p的前驱节点 |
| - | - | - | - |
| 带头结点的单链表L | L->next，时间复杂度尾O(1) | 从L->next以此遍历，时间复杂度为O(n) | 通过p->next无法找到前驱 |
| 带头结点的设头指针L的循环单链表 | L->next 时间复杂度为O(1) | 从L->next以此找到尾节点，时间复杂度为O(n) | 通过p->next可以找到*p的前驱节点，时间复杂度为O(n) |
| 带头结点仅设尾指针R的循环单链表 | R->next | R时间复杂为O(1) | 通过R-next可以找到前驱节点，时间复杂度为O(n) |
| 带头结点的双向循环链表L | L->next，时间复杂度为O(1) | L->prior，时间复杂度为O(1) | 可以直接通过p->prior找到前驱，时间复杂度为O(1) |

### 2.6 顺序表和链表的比较

链式存储结构的**优点**：
- 节点空间可以动态申请和释放
- 删除和插入节点的时候不需要移动其他节点。
链式存储结构的**缺点**：
- 存储密度小： 每个节点都要存储额外指针域占用额外的存储空间，当每个节点数据域占用的字节不多时，该问题尤为突出。
- 是非随机存取的，增加了查找了算法的复杂度。

**总结**

| 比较项目 | 顺序表 | 链表 |
| - | - | - |
| 存储空间 | 预先分配空间，存在空间闲置或者溢出的情况 | 动态分配，不会出现溢出或者闲置的情况 |
| 存储密度(数据域占用字节数/节点总字节数) | 存储密度为1 | 存储密度小于1，具体看数据域数据类型 |
| 存取元素 | 随机存取，按位置访问元素的时间复杂度为	O(1) | 顺序存取，按位置访问元素的复杂度为O(n) |
| 插入、删除 | 插入删除会整体移动数据，还会导致溢出,时间复杂度为	O(n) | 不需要移动元素，确定插入位置的情况下，时间复杂度为O(1) |
| 使用的场景 | 1.表长变化不大，且能事先确定其范围；2. 很少使用到插入或者删除写操作，经常访问书数据 | 1. 长度变化很大的场景。 2. 频繁进行插入或者删除操作 |

### 2.7 线性表的应用
【问题1】 线性表的合并：
- 问题描述： 假设利用两个线性表La和Lb分别表示两个集合A和B，现要求一个新的集合A = A U B
```
void union(List &La, List &Lb){
	La_len = ListLength(La);
	Lb_len = ListLength(Lb);
	for(int i = 0; i<Lb_len;i++)
	{
		GetElem(Lb,i,e);
		if(!LocateElem(La,e)) 
		{
			ListInsert(&La, ++La_len, e);
		}
	}
}
```
【问题2】 有序表的合并
- 问题描述： 利用线性表La和Lb中的数据元素按值
非递减有序排列，现要求La和Lb归并位一个新的线性表Lc，且Lc中的元素也是按值非递减。
算法步骤:
- 1. 创建一个空表
- 2. 依次从La或者Lb中“摘取”元素较小的结点插入到Lc的最后，直到一个La或者Lb为空。
```C++顺序存储结构
void ConnectList(SqList &La, SqList &Lb, SqList &Lc)
{	
	pa = La.elem;
	pb = Lb.elem;
	Lc.length = La.length + Lb.length;
	Lc.elem = new ElemType[Lc,length];
	pc = Lc.elem;
	pa_last = La.elem + La.length - 1;
	pb_last = Lb.elem + Lb.length - 1;
	while(pa <= pa_last && pb <=pb_last){
		if(*pa<=*pb){
			*pc++ = *pa++;
		}
		else{
			*pc++ = *pb++;
	}
	while(pa<=pa_last) *pc ++ = *pa ++;
	while(pb<=pb_last) *pc ++ = *pb ++;
}
链式存取结构
void ConnectLinkList(LinkList &La, LinkList &Lb, LinkList &Lc)
{
	Lndoe pa = La.next;
	Lnode pb = Lb.next;
	Lnode pc = Lc = La;
	while(pa!=La && pb!=Lb)
	{
		if(pa->data <= pb->data)
		{
			pc->data = pa->data;
			pc = pa;
			pa = pa->next;
			
		}
		else{
			pc->data = pb->data;
			pc = pb;
			pb = pb->next;
		}
		pc->next = pa?pa:pb;
		delete Lb;
	}
}
```
### 2.8 案例实现
【案例1】 一元多项式运算： 实现两个多项式加减乘除。

【案例2】 稀疏多项式的运算
【案例3】 图书管理系统等


## 第三章 栈和队列
### 3.1 栈和队列定义和特点
- 栈和队列是两种常用的、重要的数据结构
- 栈和队列是限定插入和删除只能在表的"端点"进行的**线性表**
- 
普通的线性表的插入和删除
- 可以在任意i位置删除和插入，需要移动

**栈(Stack)**
- 后进先出(Last In First Out, LIFO)
- 算法有后进先出的特性的话，特别方便。
- 
**术语**
- 栈顶
- 栈底
- 入栈(Push)
- 出栈(Pop)
	- 如果三个元素a、b、c入栈顺序为abc，则出栈有可能为abc、cba、acb、bca、bac

**逻辑结构**
与线性表相同

**存储结构**
可分为**顺序表**(更常用)和链表

**运算规则**
后进先出的规则

**实现方式**
根据顺序栈和链栈而不同

**队列(Queue)**
- 只能插入表尾
- 只能删除第一个元素
- 先进先出(First In First Out，FIFO)

**术语**
- 队头
- 队尾

**逻辑结构**
与线性表相同

**存储结构**
可分为**顺序表**(更常用)和链表

**运算规则**
先进先出的规则

**实现方式**
根据顺序队和链队而不同

### 3.2 案例的引入

【案例1】 进制转换
【案例2】 括号匹配
【案例3】 表达式求值（算符优先算法）
【案例4】 舞伴问题

### 3.3 栈的表示和操作的实现
**栈的抽象数据定义**
```
ADT Stack{
数据对象： D = {ai | ai 属于 ElemSet, i = 1,2,3,...,n,n>0}
数据关系： R1 = {<ai-1,ai> | ai-1, ai属于D,i = 1,2...,n}
基本操作： 初始化、进栈、出栈、取栈的元素等等
}ADT Stack
```
**InitStack(&S)**
操作结果为：构造一个空栈

**Destory(&S)**
条件： 栈存在
结果： 栈被销魂

**StackEmpty(S)**判断栈是否为空
条件： 有一个栈
结果： 返回是否为空

**StackLength(S)**求栈的长度
条件： 有一个栈
结果： 返回元素的个数，即栈的长度

**GetTop(S,&e)**取栈顶元素
条件 栈存在且不为空
结果 用e返回S的栈顶

**ClearStack(&S)**清除栈
条件 栈存在
结果 清空栈

**Push(&S,e)**入栈操作
条件： 栈存在
结果： 插入元素e作为新的栈顶元素

**Pop(&S, &e)**
条件： 栈存在
结果： 删除栈S栈顶元素an，并用e取代其值，并 返回其值。

**顺序栈的表示和实现**
- 设Top指针： 指示栈顶元素在顺序栈中的位置
- 设Base指针： 指示栈底元素在顺序栈中的位置
- 但是为了方便，通常Top指示真正的栈顶元素之上的下标地址
- 另外，用Stacksize表示栈可使用的最大容量
	- 空栈的标志为Base = Top
	- 满栈的标志为Top-Base=Satacksize
		- 满栈的处理：1. 分配一块更大的操作空间。(万不得已) 2. 报错,返回操作系统
- 上溢(Overflow)栈满->错误
- 下溢(underfkow)栈空->判断标志

**顺序栈的表示**
```c++
#define MAXSIZE 100
typedef struct{
	SElemType *base;
	SElemType *top;
	int stacksize;
}SqStack 
```

**顺序栈的初始化**
```
Status InitStack(SqStack &S)
{
	S.base = new SElemType[MAXSIZE];
	if(!S.base) exit(OVERFLOW)
	S.top = S.base;
	S.stacksize = MAXSIZE;
	return OK;
}
```

**判断是否为空**
```
Status StackEmpty(SqStack S)
{
	if(S.top() == S.base())
	{
		return TRUE;
	}
	else{
		return FALSE;
	}
}
```

**求栈的长度**
```c++
int StackLength(SqStack S)
{
	return S.top - S.base
}
```

**清空顺序栈**

```c++
int ClearStack(SqStack &S)
{
	if(S.base)
	{
		S.top = S.base
	}
	return OK;
}
```
> 太秒了,栈的每个操作都要判断是否为空,而是否为空的关键在于top和base指向的地址是否一致.这里虽然没有删除栈中所有的元素,但其他的操作都被锁死了,只能等待压栈操作输入,top指针和base不相同.从而才能进行其他操作

顺序栈入栈

````C++
Status Push(SqStack &S, SElemType e){
	//两种情况： 栈满、 栈不满 
    if(top - base == S.Stacksize){ 
    	return ERROR;
    }
    *S.top++ = e;
 	return OK;
}
````

> 运算优先级 是 = 再是 ++

栈的出栈操作:

```c++
//指针向下移动
//把值给取出来
Status Pop(SqStack &S, ElemType &e){
    if(S.top == S.base) return ERROR;
    e = *--S.top;
    return OK;
}
```

 **链栈的表示**

- 链栈式运算受限的单链表，只能在链头部进行操作

```c++
typedef structure StackNode{
 	SElemType data;  //数据域
 	struct StackNode *next; // 指针域
}StackNode, *LinkStack;
Lik
```

> 指针指向为  从栈底 指向  栈顶(怎么方便怎么来)

- 链表的头指针就是栈顶
- 不需要头结点
- 基本不存在栈满的情况
- 空栈相当于指针指向空
- 插入和删除仅在栈顶执行

链栈的初始化

```c++
void InitStack(LinkStack &S){
	S = NULL;
	return OK;
}
```

链栈判断是否为空

```c++
Status LinkStackEmpty(LinkStack S){
	if(S == NULL) return TRUE;
    else return FALSE;
}
```

链栈的入栈

```c++
Status Push(LinkStack &S, ElemType &e){
	//S是一个指针
	p = new StackNode;
	p->data = e;
	p->next = S;
	S = p;
	return OK;
}
```

链栈的出栈

```c++
Status Pop(LinkStack &S, ElemType &e){
	if(S == NULL) return ERROR;
	e = S.data;
	p = S;
	S = S->next;
	delete p;
	return OK;
}
```

取栈顶元素

```c++
Status GetTop(LinkStack S, ElemType &e){
	if (S == NULL) return ERROR; 
	e  = S.data;
    return OK;
}
```

栈与递归

- 递归的定义

  - 若一个对象部分地包含自己，或者它自己给自己定义，则称这个
  - 对象是可递归的
  - 若一个过程直接或者间接地调用自己，则这个过程就是递归过程

- 使用递归的情况

  - 1. 递归定义的数学函数

  - 2. 具有递归性质的数据结构

    - 二叉树

  - 3. 求解的问题可以采用递归解决

    - 迷宫问题

  

  **<font color = red>递归问题</font>** 是分治法求解   需要满足的条件：

  - 问题能变成一个新的问题， 而这些新问题与原问题的解法相同或者类似，不同的仅仅是处理对象，且这些处理对象要是有规律的
  - 可通过上述转化而使得问题简化
  - 必须有一个明确的递归出口， 或称为递归的边界

  ```c++
  void p(参数表){
  	if () 	可直接求解的步骤 //基本项
  	else p(); 		       //归纳项
  }
  ```

多个函数嵌套运用时 

- 遵循后调用的先返回
- 求阶乘的例子

```c++
double Fact(n){
    if(n == 0) reutrn 1
    else return n*Fact(n-1)
}
```

<font color = red>递归工作站</font>

递归的优缺点

- 结构清晰，程序易读
- 时间开销大( 时间要求比较大， 把递归变成非递归结构 )
  - 改成循环
  - 自己写循环
- 单项递归->循环结构(了解)

<font color = blue > 队列的表示和操作</font>

- 只能在表尾插入，在表头出队
- 存储形式分为： 顺序存储结构 和 链式存储结构
- 常用的应用
  - 脱机打印机
  - 操作系统
- 抽象数据定义

```c++
ADT Queue{
	数据对象
	数据关系
	基本操作
}ADT Quene
```

**队列的顺序存储**

```c++
#define MAXQSIZE 100
Typedef struct{
	QElemType *base;//指向队列的首元素
	int front;//队头
	int rear;//队尾
}SqQueue
```

**一些操作**

```c++
front = rear = 0;//初始情况
//入队
base[rear] = x;
rear++
//出队
x = base[front];
front++;
//发生溢出的两种情况
//情况一  真溢出
front = 0 ;
rear = MAXQSIZE;
//情况二  假溢出
front != 0;
rear = MAXQSIZE;
//操作方法
//每个元素移动，解决方法：
//空间循环使用 下标为0的指针接在rear的后面
//实现方法:
//模运算(求余数) 当溢出的时候，比如溢出一个则从新开始
//插入元素
Q.base[Q.rear] = x;
Q.rear = (Q.rear + 1) % MAXQSIZE;
//删除元素
x = Q.base[s.front];
Q.front = (Q.front+1)% MAXQSIZE;
//想象是一个圆形队列

//判断队伍空 和 队伍满
// 方法一  开始设置一个标志
// 方法二  另外设置一个变量，记录元素数量
// 方法三  少用一个元素空间(*)
	//队空情况:
	front == rear;
    //队满情况：
    (rear + 1) % MAXQSIZE == front;
```

**队列的初始化**

```c++
Status InitQueue (SqQueue &S){
	Q.base = new QElemType[MAXQSIEZ]; // 分配数组空间
	if(!Q.base) eixt(OVERFLOW);
    Q.front = Q.rear = 0;
    return OK;
}
```

**求队列的个数**

```c++
Status Count(SqQueue &S, int &count){
	count = (Q.base - Q.front + MAXQSIZE) % MAXQSIZE;
	return OK;
}
```

**入队算法**

```c++
Status Push(){
//先判断是否满队
	if (Q.rear+1)%MAXQSIZE == Q.front return ERROR
        Q.base[Q.rear]  = e;
    Q.rear = Q
}
```

**出队算法**



**<font color = red> 链式存储方法 </font>**

链式队列带头结点，尾指针指向头结点

- 链队列的类型定义

```c++
#define MAXQSIZE 100
typedef struct QNode{
	QElemType data;
	struct Qnode *next;
}QNode *QueuePtr;
typedef struct{
    QueuePtr front;
    QueuePtr rear;
}LinkQueue
    
// 初始化:
Status InitQueue(LinkQueue &Q){
    Q.front = Q.rear = new Qnode;
    if(!Q.front) exit(OVERFLOW);
    Q.front->next = NULL;
    return OK;
}
//销毁算法
Status Destory(LinkQueue &Q){
    while(Q.front){
        p = Q.front->next;
        delete Q.front ;
        Q.front = p;
    }
}
//入队操作
Status Insert(LinkQueue &Q, QElemType e){
    p = new Qnode;
    if(!p) exit(OVERFLOW);
    p->data = e;
    p->next = NULL;
    Q.rear.next = p;
}
//出队操作
Status Pop(LinkQueue &Q, QElemType e){
    if(Q.front == Q.rear) return ERROR;
    p = Q.front->next;
    e = p->data;
    Q.front->next = 
}
```

## 递归算法

两个关键点(必须有)：
- 会调用自身
- 终止条件

汉诺塔问题：
```python
def hanio(n, a, b, c):
	
```

